
#include <Arduino.h>
#include <SD.h>
#include <ArduinoJson.h>

#include "globals.h"
#include "storage.h"
#include "storage_indicators.h"

// ======================================================
//  SD CARD - SESSION LOGGING (APP-CONTROLLED)
// ======================================================
//
// This module is ONLY responsible for logging data to the SD card.
// Calibration is assumed to be handled elsewhere (e.g. stored in SPI flash),
// but we still accept calibration offsets as parameters so they can be written
// into the session header for traceability.
//

static bool   sdReady              = false;
static bool   sessionActive        = false;
static File   sessionFile;
static String currentSessionId;
static unsigned long lastSdFlushMs = 0;

static const unsigned long SD_FLUSH_INTERVAL_MS = 1000; // 1s
static const char *const SESSION_INDEX_PATH = "/sessions/index.ndjson";
static const char *const SESSIONS_DIR_PATH = "/sessions";

static File openForAppend(const char *path) {
    // Many SD stacks don't define FILE_APPEND; FILE_WRITE typically appends.
    File f = SD.open(path, FILE_WRITE);
    if (f) {
        f.seek(f.size());
    }
    return f;
}

static String basenameFromPath(const String &path) {
    int slash = path.lastIndexOf('/');
    if (slash < 0) return path;
    return path.substring(slash + 1);
}

static uint64_t fileMtimeMs(File &) {
    // NOTE: Not all Arduino SD / FS implementations expose a reliable mtime API.
    // Keeping this portable avoids build breaks across cores/libraries.
    return 0;
}

// Initialize SD card. Uses SD_CS defined in globals.h.
// Returns true on success.
bool storageInitSd() {
    if (sdReady) return true;

    if (!SD.begin(SD_CS)) {
        Serial.println("SD init failed");
        sdReady = false;
        return false;
    }

    // Ensure sessions directory exists
    SD.mkdir(SESSIONS_DIR_PATH);

    sdReady = true;
    Serial.println("SD init OK");
    return true;
}

// Returns true if a session is currently active.
bool storageIsSessionActive() {
    return sessionActive;
}

// Start a new session log file on SD.
//
// sessionId:  unique ID generated by the app (also used as base filename).
// exercise:   optional exercise name string ("deadlift", "squat", etc.).
// calib*  :   calibration offsets at the time of session start (for metadata only).
//
// The file is created as: /sessions/<sessionId>.tmp
// and will be renamed to .csv when storageEndSession() is called.
bool storageStartSession(const String& sessionId,
                         const String& exercise,
                         int16_t calibLaserOffset,
                         float calibRollOffset,
                         float calibPitchOffset,
                         float calibYawOffset) {
                    pulseSDCardLED();
    if (sessionActive) {
        Serial.println("storageStartSession: session already active.");
        return false;
    }

    if (!storageInitSd()) {
        return false;
    }

    currentSessionId = sessionId;

    String dir = SESSIONS_DIR_PATH;
    SD.mkdir(dir);

    if (!SD.exists(SESSION_INDEX_PATH)) {
        File idx = SD.open(SESSION_INDEX_PATH, FILE_WRITE);
        if (idx) idx.close();
    }

    String tmpPath = dir + "/" + sessionId + ".tmp";

    sessionFile = SD.open(tmpPath, FILE_WRITE);
    if (!sessionFile) {
        Serial.print("storageStartSession: failed to open ");
        Serial.println(tmpPath);
        currentSessionId = "";
        return false;
    }

    // Basic header (comment lines starting with '#')
    sessionFile.println("# liftrr session");
    sessionFile.print("# session_id="); sessionFile.println(sessionId);
    sessionFile.print("# exercise=");   sessionFile.println(exercise);
    sessionFile.print("# calib_laserOffset="); sessionFile.println(calibLaserOffset);
    sessionFile.print("# calib_rollOffset=");  sessionFile.println(calibRollOffset);
    sessionFile.print("# calib_pitchOffset="); sessionFile.println(calibPitchOffset);
    sessionFile.print("# calib_yawOffset=");   sessionFile.println(calibYawOffset);

    // CSV header
    sessionFile.println("timestamp_ms,dist_mm,relDist_mm,roll_deg,pitch_deg,yaw_deg");
    sessionFile.flush();
    sessionActive   = true;
    lastSdFlushMs   = millis();

    Serial.print("Session started: ");
    Serial.println(tmpPath);
     pulseSDCardLED();
    return true;
}

// Append a single sample to the active session file.
//
// timestampMs : millis() at sample time
// distMm      : raw distance from sensor (mm)
// relDistMm   : distance minus calibration offset (mm)
// rollDeg     : relative roll (deg)
// pitchDeg    : relative pitch (deg)
// yawDeg      : relative yaw (deg)
bool storageLogSample(uint32_t timestampMs,
                      int16_t distMm,
                      int16_t relDistMm,
                      float rollDeg,
                      float pitchDeg,
                      float yawDeg) {
    if (!sessionActive || !sessionFile) return false;
    if (!sdReady) return false;
    pulseSDCardLED();
    sessionFile.print(timestampMs);
    sessionFile.print(",");
    sessionFile.print(distMm);
    sessionFile.print(",");
    sessionFile.print(relDistMm);
    sessionFile.print(",");
    sessionFile.print(rollDeg, 3);
    sessionFile.print(",");
    sessionFile.print(pitchDeg, 3);
    sessionFile.print(",");
    sessionFile.println(yawDeg, 3);

    unsigned long now = millis();
    if (now - lastSdFlushMs > SD_FLUSH_INTERVAL_MS) {
        sessionFile.flush();
        lastSdFlushMs = now;
    }
    pulseSDCardLED();

    return true;
}

// Finalize the current session:
//
// - Flushes & closes the .tmp file
// - Renames it to .csv
//
// After this call, storageIsSessionActive() will return false.
bool storageEndSession() {
     pulseSDCardLED();
    if (!sessionActive) {
        Serial.println("storageEndSession: no active session.");
        return false;
    }

    if (!sdReady) {
        sessionActive = false;
        currentSessionId = "";
        return false;
    }

    if (sessionFile) {
        sessionFile.flush();
        sessionFile.close();
    }

    String dir = "/sessions";
    String tmpPath   = dir + "/" + currentSessionId + ".tmp";
    String finalPath = dir + "/" + currentSessionId + ".csv";

    // Try to rename; if it fails, we at least logged to the tmp file.
    if (SD.exists(tmpPath)) {
        if (!SD.rename(tmpPath, finalPath)) {
            Serial.println("storageEndSession: rename failed, leaving .tmp file.");
        } else {
            Serial.print("Session finalized: ");
            Serial.println(finalPath);
        }
    }

    String indexPath;
    if (SD.exists(finalPath)) indexPath = finalPath;
    else if (SD.exists(tmpPath)) indexPath = tmpPath;

    if (indexPath.length()) {
        File f = SD.open(indexPath, FILE_READ);
        if (f) {
            uint32_t size = f.size();
            uint64_t mtimeMs = fileMtimeMs(f);
            String name = basenameFromPath(indexPath);
            f.close();
            File idx = openForAppend(SESSION_INDEX_PATH);
            if (idx) {
                idx.print("{\"name\":\"");
                idx.print(name);
                idx.print("\",\"size\":");
                idx.print(size);
                idx.print(",\"mtime\":");
                idx.print((unsigned long long)mtimeMs);
                idx.println("}");
                idx.close();
            } else {
                Serial.println("storageEndSession: unable to append to index.");
            }
        }
    }

    sessionActive = false;
    currentSessionId = "";
    pulseSDCardLED();
    return true;
}

bool storageReadSessionIndex(size_t cursor,
                             size_t maxItems,
                             size_t *nextCursor,
                             bool *hasMore,
                             StorageSessionIndexCallback cb,
                             void *ctx) {
    if (nextCursor) *nextCursor = cursor;
    if (hasMore) *hasMore = false;
    if (!cb) return false;
    if (!storageInitSd()) return false;

    if (!SD.exists(SESSION_INDEX_PATH)) {
        return false;
    } 

    File idx = SD.open(SESSION_INDEX_PATH, FILE_READ);
    if (!idx) return false;

    size_t lineIndex = 0;
    size_t count = 0;
    size_t lastIncludedLine = cursor;

    while (idx.available()) {
        String line = idx.readStringUntil('\n');
        line.trim();
        if (line.length() == 0) {
            lineIndex++;
            continue;
        }
        if (lineIndex < cursor) {
            lineIndex++;
            continue;
        }

        if (count >= maxItems) {
            if (hasMore) *hasMore = true;
            break;
        }

        StaticJsonDocument<256> doc;
        DeserializationError err = deserializeJson(doc, line);
        if (err) {
            // Skip malformed lines but still advance the cursor so we don't loop forever.
            lastIncludedLine = lineIndex + 1;
            lineIndex++;
            continue;
        }

        const char *name = doc["name"] | "";
        uint32_t size = doc["size"] | 0;
        uint64_t mtimeMs = doc["mtime"] | (uint64_t)0;

        if (name[0] != '\0') {
            bool keepGoing = cb(name, size, mtimeMs, lineIndex, ctx);
            if (!keepGoing) {
                if (hasMore) *hasMore = true;
                break;
            }
            lastIncludedLine = lineIndex + 1;
            count++;
        }

        lineIndex++;
    }

    idx.close();
    if (nextCursor) *nextCursor = lastIncludedLine;
    return true;
}

bool storageRebuildSessionIndex(size_t *outCount) {
    if (outCount) *outCount = 0;
    if (!storageInitSd()) return false;

    File dir = SD.open(SESSIONS_DIR_PATH);
    if (!dir || !dir.isDirectory()) {
        if (dir) dir.close();
        return false;
    }

    File idx = SD.open(SESSION_INDEX_PATH, FILE_WRITE);
    if (!idx) {
        dir.close();
        return false;
    }

    size_t count = 0;
    File entry = dir.openNextFile();
    while (entry) {
        if (!entry.isDirectory()) {
            const char *rawName = entry.name();
            String baseName = basenameFromPath(String(rawName));
            if (baseName != "index.ndjson") {
                bool isSessionFile = baseName.endsWith(".csv") || baseName.endsWith(".tmp");
                if (isSessionFile) {
                    uint32_t size = entry.size();
                    uint64_t mtimeMs = fileMtimeMs(entry);
                    idx.print("{\"name\":\"");
                    idx.print(baseName);
                    idx.print("\",\"size\":");
                    idx.print(size);
                    idx.print(",\"mtime\":");
                    idx.print((unsigned long long)mtimeMs);
                    idx.println("}");
                    count++;
                }
            }
        }
        entry.close();
        entry = dir.openNextFile();
    }

    idx.close();
    dir.close();
    if (outCount) *outCount = count;
    return true;
}
